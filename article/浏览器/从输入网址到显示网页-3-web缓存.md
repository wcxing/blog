---
layout: post
title:    从输入网址到显示网页-3-web缓存
date:   2017-08-18 00:00:00 +0800
categories: CS
tag: http
---
## 背景

   如果每个web网络请求都把响应相应的资源的话，会带来更多的带宽消耗和更差的用户体验（更多的等待时间）。因此在网络请求中，使用了缓存机制。缓存有很多种，包括服务器端缓存、代理服务器缓存、cdn缓存、客户端缓存等等。本文主要讨论客户端缓存。

   客户端缓存一般有两种机制。

   如果一个资源一般情况下不会改变，那么，我们可以在响应里加入一个消息，告诉浏览器，我在24小时内基本不可能改变，那么浏览器在24小时内再次请求改资源就会直接读取浏览器中的缓存，而不会再向web服务器发出请求。这是第一种机制。

   但是资源在24小时之后还是可能未变，这时也不必返回新的资源，这就要使用第二种缓存机制。那就是当浏览器向服务器发出请求时，服务器会判断资源是否发生过改变，如果改变了，就返回新的资源，如果没有改变，就返回304，通知浏览器，资源未变，你直接读缓存就行了。你可能觉得，那不是还是发出了一次请求吗？但是如果资源比较大的话，还是可以节省带宽和时间的。

## 第一种客户端缓存机制

   第一种客户端缓存机制涉及两种主要的响应头，expires和cache-control。expires指明了资源过期截止时间，cache-control则指明了过期时长。两者类似，不过cache-control有更多的选项，控制更加精细。

## 第二种客户端缓存机制

   包括（etag/if-none-match）和(last-modified/if-modified-since）。

1）(last-modified/if-modified-since）：last-modified是响应头，if-modified-since是请求头。 这个缓存方案会由浏览器发出请求时间（if-modified-since），然后服务器会对比资源最终修改时间，若在请求时间之后又修改过资源，则返回200及资源，否则返回304，表示可读缓存。

2）（etag/if-none-match）：if-none-match是请求头，etag是响应头。这个缓存方案会由浏览器发出资源的md5（if-none-match），然后服务器会对比资源的md5，若两者不同说明资源有改动，返回200及新资源，否则返回304。etag更加精细，它相比last-modified方案有以下优点

a）可以应对资源改动但modified时间未变的情形。因为last-modified精度为秒，若资源在一秒之内有多次改动，则last-modified不会返回新资源。

b）可以应对资源未改动但modified时间改变的情形。有些资源定期刷新，但资源未变，这时last-modified会返回新的资源，实际不必。

但是etag要在每次资源改变时进行计算，因此耗费更多服务器的计算性能。因此酌情使用。

## 总结

   客户端请求到响应的整个过程中的缓存运作是 第一种缓存机制 ->第二种缓存机制。即先看过期时间，若未过期读缓存，过期则想服务器发出请求，进入第二种缓存机制，服务器判断是否需要返回新资源，是则返回200及更新的新资源，否则返回304，让浏览器读取缓存。

