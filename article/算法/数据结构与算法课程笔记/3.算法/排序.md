## 排序

#### 0. 指标

1. 时间复杂度
2. 空间复杂度

	O(1)的空间复杂度，称为“原地排序”
	
3. 稳定

	如果排序算法是稳定的，那么对于按照两种参数排序的需求，可以先按第一种参数排序，再按照第二种参数排序的方式实现。如果排序算法是不稳定的，则无法这样实现需求。

#### 1. O(n²)

1. 冒泡
2. 插入
3. 选择

算法 | 时间复杂度 | 空间复杂度 | 稳定性
:-: | :-: | :-: | :-:
冒泡 | O(n²) | O(1) | 稳定
插入 | O(n²) | O(1) | 稳定
选择 | O(n²) | O(1) | 不稳定

算法简单，适合小规模数据排序

#### 2. O(nlogn)

1. 快排
2. 堆排
3. 归并

算法 | 时间复杂度 | 空间复杂度 | 稳定性
:-: | :-: | :-: | :-:
快排 | O(nlogn) | O(1) | 不稳定
归并 | O(nlogn)) | O(n) | 稳定
堆排 | O(nlogn) | O(1) | 不稳定

快排的思想（partition），可以用来在O(n)的时间内找到第k大（小）元素。

#### 3. O(n)

1. 计数排序
2. 基数排序
3. 桶排序

#### 4. 通用、高性能排序算法

如何实现一个通用、高性能的排序算法？

首先，线性复杂度的排序函数使用场景比较特殊，因此不能选择

小规模可以使用O(n²)，大规模应该选择O(nlogn)

归并排序由于需要占用较大的空间，因此堆排和快排使用的更多

快排最坏情况下的复杂度是O(n²)，为了优化，需要取分区点时候做一些处理。

	1. 三数取中法
	2. 随机法

通用排序算法可能会在数据规模小时候使用一种排序算法，在规模大时候使用另一种排序算法

比如，数据规模小时候，使用归并或者O(n²)排序，数据规模大时候，使用快排。因为数据规模小时候时间性能可能比O(nlogn)要好。而且快排还有两个问题，就是递归时候会导致调用栈过大；分区点不好时候，时间性能会退化到O(n²)。相应的优化的手段：自己实现一个栈；优化分区点