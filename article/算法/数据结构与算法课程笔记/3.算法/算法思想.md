## 1. 贪心算法

#### 1. 贪心算法要素

1. 最优子结构
2. 贪心选择性

#### 2. 实例

1. 钱币找零
	
	有1元、5元、10元、20元、100元钱币若干，用来支付k元，最少要用多少纸币？
	
	先用面值大的支付，如果面值大的不够或者超额，换用更小一点面值的纸币，以此类推
	
2. 区间覆盖

	有n个区间，起始端点和结束端点分别是(l1, r1), (l2, r2), ... ,(ln, rn)。我们从这n个区间中选出一部分区间，这部分区间满足两两不相交，最多能选出多少个区间呢？
	
	首先将所有区间按照起始端点升序排列
	
	遍历排好序的区间序列，每次取出一个区间
		
		1. 如果这个区间左端点和已经覆盖的区间重叠
			1. 如果这个区间的右端点也和已经覆盖的区间重叠，将上一个区间丢弃，选择当前区间
			2. 如果这个区间的右端点和已经覆盖的区间未重叠，丢弃这个区间
		2. 如果这个区间左端点和已经覆盖的区间未重叠，pick it
3. 哈夫曼编码

哈夫曼编码是一种十分有效的编码方法，广泛用于数据压缩中，其压缩率通常在20%~90%之间

哈夫曼编码的思想

	1. 哈夫曼编码考虑字符个数，然后对字符进行二进制编码
	2. 在编码过程中还考虑到字符的频率，出现频率越高，编码长度越小
	3. 编码需要保证各个字符之间不会出现一个编码是另一个编码的前缀的情况

哈夫曼编码的步骤

1. 把每个字符看成一个节点，每个节点包含频率的值
2. 把字符按照频率放到优先级队列中
3. 每次从队列中取出频率最小的两个节点A、B，新建一个节点C，频率为两个节点之和，A、B作为C的两个子节点。再将C节点放到优先级队列中，重复这个过程，直到队列中没有数据
4. 然后给树中每一条指向左子节点的边标记为0，指向右子节点的边标记为1，从根节点到叶结点的路径就是叶结点对应字符的哈夫曼编码

哈夫曼编码通过贪心算法保证高频字符处于树的更靠近根节点的位置，这样其编码长度就会比较短，由字符组成的文章使用哈夫曼编码就可以很大程度压缩了
 

## 2. 分治算法

分治算法能解决的问题，需要满足下面几个条件

1. 原问题与分解的子问题有相同模式
2. 原问题分解成的子问题可以独立求解，子问题之间没有相关性
3. 具有分解终止条件
4. 可以将子问题合并成原问题，并且合并的复杂度不能太高

分治算法实例

1. 求序列的逆序对
	
	类比归并排序算法
2. 二维平面n个点中距离最近的点对

	1. 按横坐标分治
	2. 先分别求左右两个区间内最小距离
	3. 再求左右两个区间之间最小距离，使用第二步计算出的距离进行限制
3. mapreduce
4. 外排序

## 3. 回溯算法

回溯算法很多时候应用在“搜索”这类问题上，即在一组可能的解中，搜索满足期望的解

回溯的处理思想，有点类似枚举搜索。我们枚举所有的解，找到满足期望的解。为了有规律地枚举所有可能的解，避免遗漏和重复，我们把问题求解的过程分为多个阶段。每个阶段面临多个选择，随意选择一个，发现其不符合期望时候，再回退到上一个选择，重新搜索。

回溯算法很适合用递归实现

常见问题

1. 深度优先搜索
2. 八皇后
3. 0-1背包问题
4. 图的着色
5. 旅行商问题
6. 数独
7. 全排列
8. 正则表达式匹配

【思考】

回溯算法实际就是暴力穷举法（当然可以在回溯基础上做一些剪枝优化），只不过回溯算法规定了穷举的具体实现步骤。

## 4. 动态规划

