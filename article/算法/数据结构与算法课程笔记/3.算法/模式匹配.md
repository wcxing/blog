## 0. 模式匹配简述

主要概念

字符串A中查找字符串B

- A：主串（n）
- B：模式串（m）

n > m

主要算法

- BF、RK
- BM
- KMP
- trie树
- AC自动机

## 1. BF、RK算法

#### 1. BF算法

暴力匹配

时间复杂度 O(n × m)

BF比较常用，原因

1. 实际主串和模式串都比较小
2. 算法简单，不易出错

#### 2. RK算法

算法思想

1. 对主串的 n - m + 1个子串分别求hash值
2. 对模式串求hash值
3. 将主串的n - m + 1个子串与模式串对比

因为数字之间比较更快

时间复杂度O(n)

hash算法的设计

以字符集字符数K为进制表示数值（如英文字母小写，26进制）

abc =>26º + 26¹ + 26²

26^n可以缓存下来

## 2. BM算法

#### 1. BM算法简述

BM算法在模式匹配的对比过程中，当不匹配时候，尽量增加滑动个数来减少对比次数

BM算法从后往前比较（从模式串的最后一位向前）

主要有两种匹配方式

1. 坏字符：从后往前，遇到不匹配的时候，是“坏字符”
2. 好后缀：从后往前，遇到不匹配的字符时候，已经匹配了的字符叫做“好后缀”

#### 2. 算法思想

坏字符

	1. 坏字符从后往前，遇到不匹配的时候，是坏字符
	2. 滑动，将坏字符与模式串中匹配（如果匹配上多个，选择靠后的那个），匹配结果xi和主串中的坏字符所在位置（si）对齐

	坏字符思想可能出现si - xi为负的情况

好后缀

	1. 从后往前，遇到不匹配的字符时候，已经匹配了的字符叫做“好后缀”
	2. 在模式串中匹配好后缀
		1. 如果匹配到，则将主串中的好后缀和模式串中匹配到的（如果匹配上多个，选择靠后的那个）对齐
		2. 若模式串未匹配到好后缀，则在模式串所有前缀中匹配好后缀的后缀，如果有多个匹配上，则找出最大的那个，将主串中好后缀的后缀和模式串中匹配上前缀对齐

坏字符和好后缀都是利用了已知的信息（坏字符利用列某个字符没有匹配上的信息；好后缀利用了有些字符已经匹配上了的信息）来进行滑动距离优化，减少对比次数

BM算法计算在匹配过程中坏字符和好前缀的滑动距离，选择最大的那个作为滑动距离

【之所以可以在坏字符和好前缀中选择滑动距离最大的作为实际滑动距离，是因为坏字符和好后缀都能保证最小滑动】

#### 3. 实现

**坏字符的实现**

模式串中坏字符的位置（靠后的）为xi，滑动时候需要计算这个位置
	
将模式串中每个字符最后出现的位置都记录在一个散列表中
	
**好后缀的实现**

需要记录两种信息
	1. 好后缀在模式串中匹配到的位置（如果有多个，取靠后的那个）suffix
	2. 好后缀是否有后缀可以和模式串的前缀匹配 prefix

预处理模式串，得到suffix和prefix
	
模式串：c a b c a b
		0 1 2 3 4 5
	
后缀子串| 长度 | suffix | prefix 
:-: | :-: | :-: | :-: 
b | 1 | suffix[1] = 2 | prefix[1] = false
ab | 2 | suffix[1] = 1 | prefix[1] = false
cab | 3 | suffix[1] = 0 | prefix[1] = true
bcab | 4 | suffix[1] = -1 | prefix[1] = false
abcab | 5 | suffix[1] = -1 | prefix[1] = false

如何填充这两个数组

1. 遍历模式串
2. 拿模式串从0到i的子串与整个模式串求公共后缀子串
3. 若公共后缀子串长度为k，就记录suffix[k] = j（j表示公共后缀子串的起始下标）
4. 若j = 0，prefix[k] = true

#### 4. 性能优化

1. 只用好后缀而不用坏字符规则
2. 极端情况下，模式串预处理性能较差（如 aaaaaaaa 时间复杂度为O(m²)），有一些方法优化这种情况的时间性能

## 3. KMP算法

#### 1. 原理

KMP算法的思想也是将模式串与主串进行匹配，失败的话再进行滑动，根据模式串的性质让滑动的距离尽量大，这样就减少了对比的次数，从而提高了匹配的效率

在将模式串和主串对比时候，KMP算法从头向尾进行匹配，如果遇到一个不匹配的字符，将之前已经匹配上的字符称为**“好前缀”**，未匹配上的字符称为**“坏字符”**。

在遇到坏字符时候，应该如何向后滑动呢？

由于好前缀是已经匹配到主串的字符串，因此，只有当好前缀的一个前缀prefix和其等长后缀suffix匹配，将prefix和suffix对齐时候，才是一次有效的滑动，否则一定不匹配。

因此KMP算法需要计算模式串的每个前缀子串的最长可匹配前缀子串的结尾字符下标（next数组），这样在进行模式匹配时候，当遇到不匹配的字符串，可以根据已经匹配的字符串的快速找出滑动距离

模式串 ababacd

模式串前缀（好前缀候选） | 前缀结尾字符下标 | 最长可匹配前缀字符串结尾字符下标 | next值
:-: | :-: | :-: | :-:
a | 0 | -1（不存在） | next[0] = -1
ab | 1 | -1 | next[1] = -1
aba | 2 | 0 | next[2] = 0
abab | 3 | 1 | next[3] = 1
ababa | 4 | 2 | next[4] = 2
ababac | 5 | -1 | next[5] = -1


#### 2. 失效函数（next数组）的计算方法

【省略】

## Trie树

【省略】

## AC自动机

【省略】