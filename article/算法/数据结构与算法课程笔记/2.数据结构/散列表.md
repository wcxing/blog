## 散列表（哈希表）

#### 1. 概念

- 键（关键字）
- 散列函数
- 散列值
- 装载因子

#### 2. 散列表简述

散列表是利用数组的随机访问特性，实现对数据的快速存取操作的一种数据结构

散列表的工作原理是

存数据

1. 数据的标识（key，键）经过散列函数处理，得到散列值
2. 用散列值作为数组下标，保存该条数据

取数据

1. 数据的标识（key，键）经过散列函数处理，得到散列值
2. 通过散列值作为数组下标，访问相应的元素

可以看到存取数据的时间复杂度都是O(1)

散列函数要求

1. 返回值是一个非负整数
2. 键相同，散列值相同同
3. 键不同，散列值不同

散列冲突的解决方法

1. 开放寻址法：线性探测、二次（二次方）探测、双重散列
2. 链表法

**装载因子** = 填入表中的元素个数 / 表长，装载因子越大，说明空闲位置越少，冲突越多，散列表性能（存取操作的时间性能）会下降

#### 3. 实现工业级水平的散列表

工业级水平散列表的要求

1. 支持快速查询、插入、删除操作
2. 不能过分消耗内存空间
3. 性能稳定，不会退化到无法接受的情况

实现

1. 设计一个合适的散列表

	散列函数设计不能太复杂

	生成的散列值要尽可能随机且均匀分布

2. 定义装载因子阈值，设计动态扩容策略（和动态缩容）

	动态扩容（缩容）后，需要数据搬迁，会使之前的数据散列值重新计算
	
	阈值要考虑恰当，太大，会导致冲突过多，太小，会导致内存浪费严重。综合考虑空间资源和时间性能要求。
	
	高效扩容：为防止扩容瞬时压力，可以将扩容操作穿插在插入操作的过程中，扩容时候，只申请新空间，不搬迁数据。每次插入新的数据时候，在新的空间插入，并把老的空间中一个数据搬迁。这个过程中，查询数据时候，可以先从老的散列表中取，取不到再从新的空间取。
	
3. 选择合适的散列冲突解决办法

	开放寻址法和链表法的优缺点
	
	开放寻址法
	
		优点
			1. 数组访问可以利用CPU缓存，速度优于链表
			2. 序列化简单
		
		缺点
			1. 删除数据时候麻烦
			2. 装载因子大的时候，存取代价更高。如果限制装载因子不能太大，那么就会占用更多空间。
	
		适用场景：数据量小、装载因子小
	
	链表法（可以用红黑树代替链表法）
	
		优点
			1. 内存利用率更高
			2. 对装载因子的容忍度更高，装载因子大的时候，性能下降相对缓慢
			3. 支持更多优化策略（比如用红黑树、跳表代替链表）
		缺点
			1. 对于较小的数据，更耗内存（指针域）

		适用场景：大对象、大数据量

#### 3. 其他

散列表和链表经常结合使用，链表的顺序结构可以支持常见的顺序访问和高效的插入删除（O(1)操作）。结合散列表则可以让查询效率接近O(1)。