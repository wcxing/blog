## React性能优化

这里主要介绍React执行时性能优化相关，对于构建时优化不做讨论。

#### 1. 减少调和

我们知道，React在渲染组件时候，会先对虚拟DOM进行调和，即diff操作。如果发现有必要，才更改DOM。但是有些调和的操作，也可以避免。

比如，一个父组件有多个子组件，父组件给多个子组件都有传递一些属性。当父组件更新时候，可能只是想更新其中一个子组件。如果我们不作任何处理，默认会调用所有子组件的render方法，diff所有的子组件。因此我们需要寻找办法减少调和。

如何尽量减少调和呢？

答案是 shouldComponentUpdate + 不可变数据。

其中shouldComponentUpdate用来告诉React，在非必须情况下不用做diff操作。不可变数据则是用来避免我们在使用shouldComponentUpdate的时候，出现由于做浅比较导致的非预期结果。

- shouldComponentUpdate和React.pureComponet
	
	shouldComponentUpdate会在render之前执行，如果它返回false，则不需要执行render。因此我们可以在这个方法内判断，该组件关注的属性是否有变化，如果没有变化就返回false，这样就避免了不必要的diff。我们也可以通过继承React.PureComponent来实现这个效果。
	
- 不可变数据和immutable.js
	
	上述避免不必要的diff的方法有些问题。即，由于在shouldComponentUpdate中是做了浅比较，因此如果传给该组件的属性是个对象引用，其属性改变但是对象引用未改变，则不会触发render，也就不会更新。
	
	这个问题可以通过不可变数据来解决，即传给组件的属性如果有更新，则这个属性的引用（如果是对象）也要改变。这样，如果属性不变，就不会更新，属性改变，就会更新。符合我们的需求。
	
	不可变数据的需求是什么样的？
	
	不可变数据针对对象类型的数据（或者数组），一个对象（obj）有多个属性，属性可能也是一个对象类型数据，这样就形成一个树状的结构。每当这个树上有某个节点变化，那意味着子树包含这个节点的所有的树都是变化了的（而其他的节点没有变化，这个节点的子节点也没有变化），为了反映变化情况，从根节点到这个节点的路径上的节点的引用都要变化。
	
	不可变数据可以通过immutable.js来实现。immutable.js是用来生成不可变数据集合的工具，一个不可变数据集合一旦创立就不能改变，改变后会生成一个新的数据集合（老的还能用），新的数据集合会复用老的数据集合的结构，让拷贝操作最小化。

#### 2. 尽量使用函数式组件

函数式组件相对类组件有几个优点：

- 在渲染过程中，不需要创建实例，因此节省内存性能
- 更少的代码
- 更快的打包
- 易于测试

#### 3. 长列表渲染

使用虚拟滚动技术，知名的相关库有：

[react-window](https://react-window.now.sh/#/examples/list/fixed-size)
[react-virtualized](https://bvaughn.github.io/react-virtualized/#/components/List)