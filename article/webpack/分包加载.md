## 目标

分包加载的目的是减少项目迭代后用户更新资源的请求资源大小。实现的具体方式有三个关键点

- 首先是将不常改变的代码（第三方依赖（node_modules）、通用库、通用组件等）与业务代码分开打包
- 然后每个打包文件加hash后缀
- 服务器加强缓存，除非文件名（带着hash后缀）改变，否则使用浏览器本地缓存的资源

由于对静态资源的引用是根据文件名作为标识的，而不常改变的文件的文件名不变，因此每次迭代后请求的还是之前的资源，这时浏览器就会从本地缓存中读取资源，从而达到减少请求数据量的目的。

## 实现

webpack支持分包加载的配置属性是```optimization.splitChunks```

其功能是将一个入口模块或一个异步模块所对应的模块树种的公共模块按照某种规则提取出代码片，分片打包。

具体在项目中进行分包提取公共代码片时候，需要考虑几个概念和因素

### 概念

- 资源依赖图
- 代码片
- 入口模块和异步加载模块
- 缓存组

### 因素

- 要被分割出的代码块的最小尺寸
- 分割的代码块需要被引用的最小次数
- 一个入口模块或一个异步加载模块的最大并行请求数量

### 说明

webpack打包时，“一切皆模块”，webpack根据不同资源的模块引用规范（如js的 require, import. css的@import等），将被打包项目的结构抽象，建立一个依赖图，这个依赖图是一个有向图，这个图的起始节点就是入口模块。

对于通常的引用方式，webpack会以入口模块为起点将整个依赖模块树打包进同一个代码片中。webpack也提供了按需加载的引用方式，即require.ensure / import()等api会将引用的模块打包进一个分离的代码片中，webpack运行时代码会根据业务代码用诸如jsonp的方式引用被分割的异步代码片。可见，不同的入口模块和异步模块都是打包的起点，会被打包成不同的文件。

如果我们想主动分割代码，就需要对webpack进行相关配置。

对于代码分割，我们需要分割的代码片必定是一个被依赖的模块（因为入口模块和异步加载模块本来就会被webpack分割打包成不同文件，不需要我们的什么操作），通常情况下，我们希望分割的代码片都是公共模块，可能被多个入口或异步模块依赖。

之前提到，我们想分割代码的目的是希望把不常变的模块分割出来，以减少迭代后用户的请求数。但是，我们还需要考虑其他因素。

**被引用次数**  首先，因为我们希望将不常变的模块提取出来，那么我们如何判断一个模块是否经常变化呢？如果我们确定某些模块是不常变的，那可以直接将其分割打包出来。对于我们不确定的模块，我们可以根据模块被引用的次数来进行估计，我们认为，一个模块如果被更多的入口模块或者异步模块引用，那它就应该是通用性更强的模块，就更可能是不常变的。因此，具体操作时，我们需要设定一个被引用次数下限，大于等于这个下限时候，才需要将模块打包。

**最小尺寸**  虽然我们希望将不常变得模块分离出来，但是并不意味着所有的不常变的模块都分割出来是一个好的选择。如果一个模块体积很小，那么多出的请求也是一个很大的负担。因此我们要考虑模块的体积这个因素。只有体积大到一定程度时，我们才给其被分割的资格。

**入口模块和异步模块的最大并行请求数**  代码被分割后，在运行时是如何被加载的呢？比如从一个入口模块为起点打包，有多个被分割的模块，那么加载这个入口模块后，webpack运行时代码会起作用，会发起http请求将分割代码请求到浏览器端。 之前提到，分割代码的好处是可以在迭代后减小需要请求的资源量。但是如果我们过分分割代码，也会引来别的问题，那就是，会造成一个入口模块或这个异步模块加载后再加载分割代码的并行请求数太大，会影响web app的性能。因此我们需要控制入口模块和异步模块的最大并行请求数，我们需要给入口模块和异步模块设定并行请求数上限，在打包过程中，若是分割打包模块到达这个上限，就会不进行分割打包，那么我们希望在达到这个上限后，哪些被打包，哪些不被打包呢？这就需要我们配置分割打包的优先级。

### optimization.splitChunks

optimization.splitChunks这个选项提供给我们去配置分割打包的一些规则。这里我们需要了解一下**缓存组**的概念。**缓存组**指的是最终被打包出来的代码片需要满足的条件。

从开发者的角度，在配置分割打包时，我们需要告诉webpack，我们希望将什么样的模块打包，即希望将满足什么条件的模块打包。我们通过一系列配置项来描述这些条件。如果我们想打多个包，那么我们就需要告诉webpack每个包都会将什么样的模块打包进去，每个打包的条件配置项就是一个缓存组。

从webpack角度，webpack在打包时，会解析```optimization.splitChunks```配置项，在满足代码片数量不超过最大并行请求数的情况下，每个缓存组都会被打包成一个代码片，每个代码片里包含满足这个缓存组的配置项的所有模块。

下面介绍下```optimization.splitChunks ```的常见配置选项

#### 最大并发请求数```maxInitialRequests ```和```maxAsyncRequests ```
这两个参数用来配置入口模块最大并发请求数和异步模块最大并发请求数

#### 缓存组```cacheGroups```

```cacheGroups```用于描述开发者希望打包的代码片所要满足的条件

缓存组里常见的配置项：

- ```test```可以被打包模块的路径正则
- ```priority```用于控制 当 因分割打包的个数到达入口模块或者异步模块的最大并发请求上限 而 放弃打包某些缓存组 时，实际打包时被打包缓存组的优先级，webpack会放弃优先级较低的缓存组
- ```chunks```用于说明依赖被打包模块的模块的类型，该属性有三个可能的值 ```all```，```async```和```initial ```。比如，如果配置项为```initial```，则webpack在做代码分割提取公共模块时，只会考虑入口模块，而不考虑异步模块
- ```minSize```最小切片，用于控制可以被提取的代码片的最小尺寸，如果满足该缓存组其他条件的所有模块打包体积小于该选项的值，则不会被打包
- ```minChunks```用于说明被打包模块需要被依赖的最小次数

值得说明的是，webpack提供了一个特性，即缓存组中的配置项```chunks ```，```minSize ```，```minChunks```都可以继承```optimization.splitChunks ```下的值。

如以下配置：

```
optimization: {
    splitChunks: {
        chunks: 'all',
        minSize: 0,
        minChunks: 1,
        maxAsyncRequests: 5,
        maxInitialRequests: 3,
        cacheGroups: {
            util: {
                test: /util/,
                // priority: 10
            },
            lib: {
                test: /lib/,
            },
            common: {
                test: /common/
            }
        }
    }
}
```

其中缓存组 ```util ```，```lib ```和```common ```里的```chunks ```，```minSize ```和```minChunks ```选项都会继承```splitChunks```中的相应属性值